#include <avr/io.h>
#include <util/delay.h>
#define _BV(bit) (1<<(bit))
#define sbi(reg,bit) reg |= (_BV(bit))
#define cbi(reg,bit) reg &= ~(_BV(bit))

uint8_t tab[10] = {
0b11000000, // 0
0b11111001, // 1
0b10100100, // 2
0b10110000, // 3
0b10011001, // 4
0b10010010, // 5
0b10000010, // 6
0b11111000, // 7
0b10000000, // 8
0b10010000 // 9
};

int32_t x = 1234000; //32 bo zakres za mały inaczej i z minusami na wypadek wejścia na ujemne przez odejmowanie
bool running = false; // false - ustawianie czasu, true - odliczanie

void display_number(uint8_t segment, uint8_t number){
  PORTD = tab[number]; // Ustaw wartość dla segmentów
  sbi(PORTC, segment); // Aktywuj odpowiedni segment
  _delay_ms(5); // Odczekaj wystarczająco długo, aby cyfra była widoczna,ale szybko, aby uniknąć migotania
  cbi(PORTC, segment); // Wyłącz segment
}

void buzzer(){  // Wywołuje buzzer na 2 sekundy
  sbi(PORTB, 4);
  _delay_ms(2000);
  cbi(PORTB, 4);
}

int main() {
DDRD = 0xFF; // Piny D na wyjście
DDRC = 0xFF; // Piny C na wyjście
PORTC = 0x00; // Stan niski na portach C do włączania przez display_number
DDRB = 0x00;  //  Piny B na wejście
PORTB = 0x0F; //  PB0, PB1, PB2, PB3 piny na wejście pull-up
sbi(DDRB, 4); // Pin PB4 na wyjście dla buzzera

while(1) {
display_number(0, x / 1000000 % 10);
display_number(1, x / 100000 % 10);
display_number(2, x / 10000 % 10);
display_number(3, x / 1000 % 10);

if(bit_is_clear(PINB, 0) && running == false){  //Dodawanie 1 sekundy
    _delay_ms(20);
        if(bit_is_clear(PINB, 0)){  //Po 20ms sprawdzenie czy przycisk dalej jest wciśnięty, rozwiązanie na drgania styków
          if(x < 9999000){  // Zeby nie wyjść poza zakres
           x += 1000;
          }
        }
        while (bit_is_clear(PINB, 0));  //Brak reakcji na przytrzymanie przycisku
      }


if(bit_is_clear(PINB, 1) && running == false){  //Odejmowanie 1 sekundy
        _delay_ms(20);
        if(bit_is_clear(PINB, 1)){  //Po 20ms sprawdzenie czy przycisk dalej jest wciśnięty, rozwiązanie na drgania styków
          if(x >= 1000){  // Zeby nie wyjść poza zakres
           x -= 1000;
          }
        }
        while (bit_is_clear(PINB, 1));  //Brak reakcji na przytrzymanie przycisku
      }


if(bit_is_clear(PINB, 2)){  //Resetowanie czasu i/lub zatrzymywanie czasu
        _delay_ms(20);
        if(bit_is_clear(PINB, 2)){  //Po 20ms sprawdzenie czy przycisk dalej jest wciśnięty, rozwiązanie na drgania styków
          if(running == false){
             x = 0;  // Wyzerowanie timera podczas ustawiania czasu
          }
          else if(running == true){
            running = false;  // Zatrzymanie odliczania
            //x = 0;  // I zresetowanie timera
          }
        }
        while (bit_is_clear(PINB, 2));  //Brak reakcji na przytrzymanie przycisku
      }


if(bit_is_clear(PINB, 3)){  //  Start odliczania
        _delay_ms(20);
        if(bit_is_clear(PINB, 3)){  //Po 20ms sprawdzenie czy przycisk dalej jest wciśnięty, rozwiązanie na drgania styków
          running = true; // Uruchomienie odliczania
        }
        while (bit_is_clear(PINB, 3));  //Brak reakcji na przytrzymanie przycisku
      }
  
if(running == true){  //  Odliczanie czasu
    x-=20;  // 20 bo wyświetlenie wszystkich cyfr trwa 20ms przez delaye
  }

if(x < 0){ // poniżej 0 sekundy, uruchomienie buzzera
  running = false;  // zakończenie odliczania
  x = 0;  // Zresetowanie ilości sekund
  buzzer();
  
}


  }
}